#!/usr/bin/env ts-node
/**
 * Generates a list of AWS service prefixes that support tag policies
 * Each service uses the ALL_SUPPORTED wildcard (e.g., ec2:ALL_SUPPORTED)
 */

import * as fs from 'fs';
import * as path from 'path';

/**
 * AWS service prefixes that support tag policies
 * Format: service:ALL_SUPPORTED (e.g., "ec2:ALL_SUPPORTED")
 *
 * Reference: https://docs.aws.amazon.com/organizations/latest/userguide/orgs_manage_policies_supported-resources-enforcement.html
 */
const SUPPORTED_SERVICES = [
  { prefix: "access-analyzer", name: "IAM Access Analyzer" },
  { prefix: "apigateway", name: "API Gateway" },
  { prefix: "appmesh", name: "AWS App Mesh" },
  { prefix: "appstream", name: "Amazon AppStream 2.0" },
  { prefix: "athena", name: "Amazon Athena" },
  { prefix: "cloudformation", name: "AWS CloudFormation" },
  { prefix: "cloudfront", name: "Amazon CloudFront" },
  { prefix: "cloudtrail", name: "AWS CloudTrail" },
  { prefix: "cloudwatch", name: "Amazon CloudWatch" },
  { prefix: "codebuild", name: "AWS CodeBuild" },
  { prefix: "codecommit", name: "AWS CodeCommit" },
  { prefix: "codepipeline", name: "AWS CodePipeline" },
  { prefix: "config", name: "AWS Config" },
  { prefix: "dynamodb", name: "Amazon DynamoDB" },
  { prefix: "ec2", name: "Amazon EC2" },
  { prefix: "ecr", name: "Amazon ECR" },
  { prefix: "ecs", name: "Amazon ECS" },
  { prefix: "elasticfilesystem", name: "Amazon EFS" },
  { prefix: "eks", name: "Amazon EKS" },
  { prefix: "elasticbeanstalk", name: "AWS Elastic Beanstalk" },
  { prefix: "elasticache", name: "Amazon ElastiCache" },
  { prefix: "elasticloadbalancing", name: "Elastic Load Balancing" },
  { prefix: "es", name: "Amazon OpenSearch Service" },
  { prefix: "events", name: "Amazon EventBridge" },
  { prefix: "fsx", name: "Amazon FSx" },
  { prefix: "glue", name: "AWS Glue" },
  { prefix: "iam", name: "AWS IAM" },
  { prefix: "kinesis", name: "Amazon Kinesis" },
  { prefix: "kms", name: "AWS KMS" },
  { prefix: "lambda", name: "AWS Lambda" },
  { prefix: "logs", name: "Amazon CloudWatch Logs" },
  { prefix: "rds", name: "Amazon RDS" },
  { prefix: "redshift", name: "Amazon Redshift" },
  { prefix: "route53", name: "Amazon Route 53" },
  { prefix: "s3", name: "Amazon S3" },
  { prefix: "sagemaker", name: "Amazon SageMaker" },
  { prefix: "secretsmanager", name: "AWS Secrets Manager" },
  { prefix: "sns", name: "Amazon SNS" },
  { prefix: "sqs", name: "Amazon SQS" },
  { prefix: "states", name: "AWS Step Functions" },
  { prefix: "ssm", name: "AWS Systems Manager" },
  { prefix: "waf", name: "AWS WAF" },
  { prefix: "wafv2", name: "AWS WAFv2" },
  { prefix: "workspaces", name: "Amazon WorkSpaces" },
];

function generateTypeScriptFile(): string {
  return `/**
 * AWS Service Prefixes that support Tag Policies
 * Generated by: npm run refresh-tags
 * Last updated: ${new Date().toISOString()}
 *
 * Each service uses the ALL_SUPPORTED wildcard format: service:ALL_SUPPORTED
 * Example: "ec2:ALL_SUPPORTED" covers all EC2 resource types that support tag policies
 *
 * To update this list:
 * 1. Edit scripts/fetch-supported-resources.ts
 * 2. Add new services to SUPPORTED_SERVICES array
 * 3. Run: npm run refresh-tags
 *
 * Reference:
 * - https://docs.aws.amazon.com/organizations/latest/userguide/orgs_manage_policies_supported-resources-enforcement.html
 * - https://docs.aws.amazon.com/organizations/latest/userguide/orgs_manage_policies_example-tag-policies.html
 */

export interface ServiceInfo {
  /** AWS service prefix (e.g., 'ec2', 's3', 'rds') */
  prefix: string;
  /** Human-readable service name */
  name: string;
}

/**
 * List of AWS services that support tag policies
 */
export const SUPPORTED_SERVICES: ServiceInfo[] = [
${SUPPORTED_SERVICES.map(s => `  { prefix: "${s.prefix}", name: "${s.name}" },`).join('\n')}
];

/**
 * Get all service prefixes
 */
export function getServicePrefixes(): string[] {
  return SUPPORTED_SERVICES.map(s => s.prefix);
}

/**
 * Get enforced_for values for tag policy (service:ALL_SUPPORTED format)
 */
export function getEnforcedForValues(): string[] {
  return SUPPORTED_SERVICES.map(s => \`\${s.prefix}:ALL_SUPPORTED\`);
}

/**
 * Get services grouped by category
 */
export function getServicesByCategory(): Record<string, ServiceInfo[]> {
  const categories: Record<string, ServiceInfo[]> = {
    "Compute": [],
    "Storage": [],
    "Database": [],
    "Networking & Content Delivery": [],
    "Security & Identity": [],
    "Management & Governance": [],
    "Analytics": [],
    "Application Integration": [],
    "Developer Tools": [],
  };

  // Simple categorization
  const computeServices = ["ec2", "lambda", "ecs", "eks", "elasticbeanstalk"];
  const storageServices = ["s3", "elasticfilesystem", "fsx"];
  const databaseServices = ["dynamodb", "rds", "elasticache", "redshift"];
  const networkingServices = ["cloudfront", "route53", "apigateway", "elasticloadbalancing"];
  const securityServices = ["iam", "kms", "secretsmanager", "access-analyzer", "waf", "wafv2"];
  const managementServices = ["cloudformation", "cloudwatch", "cloudtrail", "config", "logs", "ssm"];
  const analyticsServices = ["athena", "glue", "kinesis", "es"];
  const integrationServices = ["events", "sns", "sqs", "appmesh", "states"];
  const developerServices = ["codebuild", "codecommit", "codepipeline"];

  SUPPORTED_SERVICES.forEach(service => {
    if (computeServices.includes(service.prefix)) {
      categories["Compute"].push(service);
    } else if (storageServices.includes(service.prefix)) {
      categories["Storage"].push(service);
    } else if (databaseServices.includes(service.prefix)) {
      categories["Database"].push(service);
    } else if (networkingServices.includes(service.prefix)) {
      categories["Networking & Content Delivery"].push(service);
    } else if (securityServices.includes(service.prefix)) {
      categories["Security & Identity"].push(service);
    } else if (managementServices.includes(service.prefix)) {
      categories["Management & Governance"].push(service);
    } else if (analyticsServices.includes(service.prefix)) {
      categories["Analytics"].push(service);
    } else if (integrationServices.includes(service.prefix)) {
      categories["Application Integration"].push(service);
    } else if (developerServices.includes(service.prefix)) {
      categories["Developer Tools"].push(service);
    }
  });

  return categories;
}
`;
}

async function main() {
  console.log('Generating AWS service prefixes for tag policies...\n');

  const outputPath = path.join(__dirname, '..', 'generated', 'supported-resources.ts');
  const outputDir = path.dirname(outputPath);

  // Ensure output directory exists
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  // Generate the TypeScript file
  const content = generateTypeScriptFile();
  fs.writeFileSync(outputPath, content, 'utf8');

  console.log(`✓ Generated ${SUPPORTED_SERVICES.length} service prefixes`);
  console.log(`✓ Output written to: ${outputPath}`);
  console.log('\nSupported AWS Services:');

  SUPPORTED_SERVICES.forEach(service => {
    console.log(`  - ${service.name} (${service.prefix}:ALL_SUPPORTED)`);
  });

  console.log('\nUsage in tag policy:');
  console.log('  "enforced_for": {');
  console.log('    "@@assign": [');
  console.log('      "ec2:ALL_SUPPORTED",');
  console.log('      "s3:ALL_SUPPORTED",');
  console.log('      "rds:ALL_SUPPORTED",');
  console.log('      ...');
  console.log('    ]');
  console.log('  }');

  console.log('\nTo add more services:');
  console.log('  1. Edit scripts/fetch-supported-resources.ts');
  console.log('  2. Add entries to the SUPPORTED_SERVICES array');
  console.log('  3. Run: npm run refresh-tags');
  console.log('\nReference: https://docs.aws.amazon.com/organizations/latest/userguide/orgs_manage_policies_supported-resources-enforcement.html');
}

main().catch(console.error);
